/*
 * Copyright (C) 2017 Red Rocket Computing, LLC
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * memory.ld
 *
 * Created on: Mar 16, 2017
 *     Author: Stephen Street (stephen@redrocketcomputing.com)
 */

/* Linker script to place sections and symbol values. Should be used together
 * with other linker script that defines memory regions FLASH and RAM.
 * It references following symbols, which must be defined in code:
 *   Reset_Handler : Entry of reset handler
 *
 * It defines following symbols, which code can use without definition:
 *   __exidx_start
 *   __exidx_end
 *   __extab_start
 *   __extab_end
 *   __copy_table_start__
 *   __copy_table_end__
 *   __zero_table_start__
 *   __zero_table_end__
 *   __etext
 *   __data_start__
 *   __preinit_array_start
 *   __preinit_array_end
 *   __init_array_start
 *   __init_array_end
 *   __fini_array_start
 *   __fini_array_end
 *   __data_end__
 *   __bss_start__
 *   __bss_end__
 *   __start__
 *   __end__
 *   end
 *   __HeapLimit
 *   __StackLimit
 *   __StackTop
 *   __stack
 *   __Vectors_Start
 *   __Vectors_End
 *   __Vectors_Size
 */

ENTRY(Reset_Handler)

SECTIONS
{
	__start__ = ORIGIN(TEXT);
	.vectors :
	{
		. = ALIGN(4);

		__vectors_start__ = .;
		KEEP(*(.vectors))
		__vectors_end__ = .;
		
		*(.after_vectors.* .after_vectors)

	} > TEXT
	__vectors = LOADADDR(.vectors);
	__vectors_size = __vectors_end__ - __vectors_start__;
	
    .inits :
    {
		. = ALIGN(4);
		__inits_start__ = .;
		
         /* The preinit code */ 
		. = ALIGN(4);
		PROVIDE_HIDDEN(__preinit_array_start = .);

		KEEP(*(SORT(.preinit_array_sysinit.*)))
		KEEP(*(.preinit_array_sysinit))

		KEEP(*(SORT(.preinit_array_platform.*)))
		KEEP(*(.preinit_array_platform))

		KEEP(*(SORT(preinit_array.*)))
		KEEP(*(.preinit_array))

		PROVIDE_HIDDEN(__preinit_array_end = .);

		/* init data */
		. = ALIGN(4);
		PROVIDE_HIDDEN(__init_array_start = .);
		KEEP(*(SORT(.init_array.*)))
		KEEP(*(.init_array))
		PROVIDE_HIDDEN(__init_array_end = .);

		/* fini data */
		. = ALIGN(4);
		PROVIDE_HIDDEN(__fini_array_start = .);
		KEEP(*(SORT(.fini_array.*)))
		KEEP(*(.fini_array))
		PROVIDE_HIDDEN(__fini_array_end = .);

		__inits_end__ = .;

    } >TEXT
	__inits = LOADADDR(.inits);
	__inits_size = __inits_end__ - __inits_start__;
	
	.text :
	{
		. = ALIGN(4);
		__text_start__ = .;

		*(.text .text.*)

		*(vtable)

		/* .ctors */
		*crtbegin.o(.ctors)
		*crtbegin?.o(.ctors)
		*(EXCLUDE_FILE(*crtend?.o *crtend.o) .ctors)
		*(SORT(.ctors.*))
		*(.ctors)

		/* .dtors */
 		*crtbegin.o(.dtors)
 		*crtbegin?.o(.dtors)
 		*(EXCLUDE_FILE(*crtend?.o *crtend.o) .dtors)
 		*(SORT(.dtors.*))
 		*(.dtors)

		KEEP(*(.eh_frame*))
		
		/*
		 * Stub sections generated by the linker, to glue together 
		 * ARM and Thumb code. .glue_7 is used for ARM code calling 
		 * Thumb code, and .glue_7t is used for Thumb code calling 
		 * ARM code. Apparently always generated by the linker, for some
		 * architectures, so better leave them here.
		 */
		*(.glue_7)
		*(.glue_7t)
		
		. = ALIGN(4);
		__text_end__ = .;
	} > TEXT
	__text = LOADADDR(.text);
	__text_size = __text_end__ - __text_start__;		

	.rodata :
	{
		. = ALIGN(4);

		__rodata_start__ = .;
		*(.rodata .rodata.*);

		. = ALIGN(4);
		__rodata_end__ = .;
	} > RODATA
	__rodata = LOADADDR(.rodata);
	__rodata_size = __rodata_end__ - __rodata_start__;
	
	.ARM.extab :
	{
		. = ALIGN(4);
		__extab_start__ = .;
		__extab_start = .;
		*(.ARM.extab* .gnu.linkonce.armextab.*)
		__extab_end = .;
		__extab_end__ = .;
	} > TEXT
	__extab_size = __extab_end__ - __extab_start__;

	.ARM.exidx :
	{
		. = ALIGN(4);
		__exidx_start__ = .;
		__exidx_start = .;
		*(.ARM.exidx* .gnu.linkonce.armexidx.*)
		__exidx_end = .;
		__exidx_end__ = .;
	} > TEXT
	__exidx_size = __exidx_end__ - __exidx_start__;

	__unwind_info = LOADADDR(.ARM.extab);
	__unwind_info_size =  (__extab_end__ - __extab_start__) + (__exidx_end__ - __exidx_start__);

	.data :
	{
	    . = ALIGN(4);
		__data_start__ = .;
		*(.data_begin .data_begin.*)
		*(.data .data.*)
		*(.data_end .data_end.*)

		. = ALIGN(4);
		__data_end__ = .;
	} > DATA AT>TEXT
	__data = LOADADDR(.data);
	__end__ = LOADADDR(.data) + SIZEOF(.data);
	__data_size = __data_end__ - __data_start__;

	.bss :
	{
		. = ALIGN(4);
		__bss_start__ = .;
        *(.bss_begin .bss_begin.*)
        *(.bss .bss.*)
        *(COMMON)
        *(.bss_end .bss_end.*)
        
		. = ALIGN(4);
		__bss_end__ = .;
	} > BSS
	__bss = LOADADDR(.bss);
	__bss_size = __bss_end__ - __bss_start__;

 	.copy.table :
	{
		. = ALIGN(4);
		__copy_table_start__ = .;
		
		LONG(__data)
		LONG(__data_start__)
		LONG(__data_end__ - __data_start__)
		
		__copy_table_end__ = .;
	} > TEXT

	.zero.table :
	{
		. = ALIGN(4);
		__zero_table_start__ = .;
		
		LONG(__bss_start__)
		LONG(__bss_end__ - __bss_start__)
		
		__zero_table_end__ = .;
	} > TEXT
	
	.heap :
	{
		. = ALIGN(4);
		__heap_start__ = .;
		__heap_end__ = ORIGIN(HEAP) + LENGTH(HEAP);
	} > HEAP
	__heap = LOADADDR(.heap);
	__heap_size = __heap_end__ - __heap_start__;
	
	/* Set __stack to top of the stack region */
	PROVIDE(__stack = ORIGIN(STACK) + LENGTH(STACK));
}
